---
title: "Preprocessing RShiny"
author: "Group6 - Claude Widmer"
format: html
editor: visual
---

# Preprocessing For RShiny App

Before integrating the data into the RShiny application, we perform preprocessing after the initial exploratory data analysis (EDA). To enhance performance, all necessary calculations and data transformations are conducted at this stage. The processed data is then exported as .geojson or .csv files, ready for seamless import into the RShiny app.

```{r}
#| message: false
#| warning: false
library(dplyr)
library(sf)
library(tmap)
library(tidyr)
library(dbscan)


bird_data <- read.csv("data/NuCra_Davos_all_data_2025-02-07_V2.csv")
dir.create("preprocessing_export", showWarnings = FALSE)

# Check and handle missing values if any
bird_data <- bird_data %>% drop_na(longitude, latitude, datetime)
remove_ids <- c(48325, 15381, 15382, 15383, 45363, 7949)
bird_data <- bird_data %>% filter(!X %in% remove_ids)

# Convert datetime to proper format
bird_data$datetime <- as.POSIXct(bird_data$datetime, format="%Y-%m-%d %H:%M:%S", tz="UTC")

# Convert to sf object
bird_data <- bird_data %>%
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326) %>%
  arrange(id, datetime)  # Ensure ordered by bird and time

# Create line geometries per bird
bird_tracks <- bird_data %>%
  group_by(id) %>%
  summarise(geometry = st_cast(st_combine(geometry), "LINESTRING"), .groups = 'drop')

# Count number of unique bird groups
num_groups <- n_distinct(bird_tracks$id)
print(paste("Number of unique bird groups:", num_groups))

# Save processed data
st_write(bird_tracks, "preprocessing_export/bird_tracks.geojson", delete_dsn = TRUE)
```

# Preprocess Cluster Analysis (DBScan)

For each bird, we apply DBScan clustering with a minimum points (minPts) parameter set to 15. The eps parameter is dynamically calculated as the mean of the k-nearest neighbor (kNN) distances, ensuring adaptive and data-driven clustering.


```{r}
# Apply DBScan per bird ID
bird_data$cluster <- NA  # Initialize cluster column
unique_ids <- unique(bird_data$id)
minPts <- 15

for (bird_id in unique_ids) {
  bird_subset <- bird_data[bird_data$id == bird_id, ]
  coords <- st_coordinates(bird_subset)
  num_points <- nrow(coords)
  
  # Check if sufficient points are available
  if (num_points >= minPts) {
    knn_distances <- dbscan::kNNdist(coords, k = minPts/2)
    eps <- mean(knn_distances, na.rm = TRUE)
    db <- dbscan(coords, eps = eps, minPts = minPts)
    bird_data$cluster[bird_data$id == bird_id] <- as.factor(db$cluster)
  } else {
    message(paste("Not enough points for ID", bird_id, "- Only", num_points, "points available."))
  }
}

# Save as geojson
st_write(bird_data, "preprocessing_export/bird_data.geojson", delete_dsn = TRUE)
```

# Visualize

To verify the effectiveness of the preprocessing and clustering, we create visualizations that illustrate the clustering results. This step ensures that the DBScan algorithm has accurately identified clusters based on the calculated eps values.

```{r}
# Visualize Clusters for Specific ID
target_id <- '.458'
print(target_id)
bird_data_filtered <- bird_data[bird_data$id == target_id, ]

if (nrow(bird_data_filtered) > 0) {
  tmap_mode("view")
  tm_shape(bird_data_filtered) +
    tm_dots(col = "cluster", palette = "Set1", title = "Cluster ID") +
    tm_layout(title = paste("Clusters for ID", target_id))
} else {
  print("No data available for the specified ID")
}

```

# Prepare Data for Export of DB-Clusters

## DBScan Algorithm

In this step, we structure the data for export to .geojson files. Each bird's DBScan clusters are saved as individual .geojson files, with each file containing the cluster polygons for that specific bird, facilitating organized data handling and subsequent analysis.

```{r}
convex_hulls_polygons <- st_sfc()
convex_hulls_ids <- c()

for (id_name in unique(bird_data$id)) {
  convex_hulls <- list()
  selected_data <- bird_data[bird_data$id == id_name, ]
  clusters <- unique(na.omit(selected_data$cluster))
  
  if (length(clusters) == 0) {
    next
  }

  # Loop through each cluster
  for (i in clusters) {
    # Filter data by cluster
    cluster_data <- selected_data[selected_data$cluster == i, ]
    # Calculate convex hull only if there are more than 3 points
    if (nrow(cluster_data) > 3) {
      hull <- st_convex_hull(st_union(cluster_data))
      convex_hulls[[paste(id_name, i, sep = "_")]] <- hull
    }
  }

  if (length(convex_hulls) > 0) {
    sf_object_convex_hull_geom <- st_sfc(unlist(convex_hulls, recursive = FALSE))
    # Remove the largest polygon
    if (length(sf_object_convex_hull_geom) > 1) {
      sf_object_convex_hull_geom <- sf_object_convex_hull_geom[-which.max(st_area(sf_object_convex_hull_geom))]
    }

    convex_hulls_polygons <- c(convex_hulls_polygons, sf_object_convex_hull_geom)
    convex_hulls_ids <- c(convex_hulls_ids, rep(id_name, length(sf_object_convex_hull_geom)))
  }
}

convex_hulls_polygons <- st_set_crs(convex_hulls_polygons, 4326)
convex_hulls_sf <- st_as_sf(data.frame(id = convex_hulls_ids, geometry = convex_hulls_polygons))


st_write(convex_hulls_sf, "preprocessing_export/DB_Scan_polygons.geojson", delete_dsn = TRUE)
```
## Calculate Overlap Matrix

The overlap matrix is calculated to identify intersecting DBScan clusters between birds. The function calculate_overlap_matrix() uses vectorized operations to efficiently compute the intersections and generate a symmetric matrix, indicating overlap presence with binary values. The resulting matrix is exported as a .csv file for further analysis.

```{r}
#| warning: false

# Funktion zur Berechnung der Overlap-Matrix
# Funktion zur effizienten Berechnung der Overlap-Matrix
calculate_overlap_matrix <- function(DB_Scan_data) {
  # Extrahiere eindeutige Vogel-IDs
  bird_ids <- unique(DB_Scan_data$id)
  n <- length(bird_ids)
  
  # Erstelle eine leere Overlap-Matrix
  overlap_matrix <- matrix(0, nrow = n, ncol = n, dimnames = list(bird_ids, bird_ids))
  
  # Nutze Vektorisierung zur Berechnung der Overlaps
  for (i in 1:(n - 1)) {
    bird1_data <- DB_Scan_data[DB_Scan_data$id == bird_ids[i], ]

    for (j in (i + 1):n) {
      bird2_data <- DB_Scan_data[DB_Scan_data$id == bird_ids[j], ]

      # Berechne die Intersection
      intersection <- st_intersection(bird1_data, bird2_data)

      # Überprüfe, ob eine Intersection vorhanden ist
      overlap_matrix[i, j] <- ifelse(nrow(intersection) > 0, 1, 0)
      overlap_matrix[j, i] <- overlap_matrix[i, j]
    }
  }
  return(overlap_matrix)
}

# Beispielaufruf
overlap_matrix <- calculate_overlap_matrix(convex_hulls_sf)
write.csv(overlap_matrix, 'preprocessing_export/DB_Scan_Matrix.csv')

```

## Function to find relatable birds

The find_related_birds() function identifies birds with overlapping DBScan clusters based on the overlap matrix. By inputting a specific bird ID, the function extracts all bird IDs with intersecting clusters (indicated by a value of 1 in the matrix). This provides a quick way to find potential interactions or shared areas among birds.

```{r}
find_related_birds <- function(matrix_data, bird_id) {
  if (!(bird_id %in% rownames(matrix_data))) {
    stop("Die angegebene Vogel-ID existiert nicht in der Matrix.")
  }

  # Finde die Zeile, die der bird_id entspricht
  bird_row <- matrix_data[as.character(bird_id), ]

  # Extrahiere die IDs der ähnlichen Vögel (Spalten mit Wert 1)
  similar_birds <- colnames(matrix_data)[which(bird_row == 1)]

  return(similar_birds)
}

find_related_birds(overlap_matrix, "7934")
```




